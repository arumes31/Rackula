server {
    listen ${RACKULA_LISTEN_PORT};
    listen [::]:${RACKULA_LISTEN_PORT};
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied expired no-cache no-store private auth;
    gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml application/javascript application/json image/svg+xml;

    # Cache static assets (fingerprinted by Vite — safe to cache forever)
    location /assets/ {
        expires 1y;
        add_header Cache-Control "public, immutable";

        # nginx drops ALL server-level add_header directives when a location block
        # defines its own — include shared security headers to avoid drift.
        include /etc/nginx/snippets/security-headers.conf;
    }

    # API proxy (when sidecar is running)
    # Use variable to defer DNS resolution to request time (allows nginx to start without API)
    # Using $uri$is_args$args for normalized path+query (safer than $request_uri)
    # Configure via environment variables: API_HOST (default: rackula-api), API_PORT (default: 3001)
    # Note: NGINX_ENVSUBST_FILTER in Dockerfile restricts substitution to API_HOST, API_PORT, and RACKULA_LISTEN_PORT only
    
    # API health check - used by frontend to detect persistence API availability
    # Returns 502/503 if API is unavailable (intentional - signals API is down)
    # Preserves query parameters for potential diagnostics/verbosity flags
    location = /api/health {
        resolver 127.0.0.11 valid=30s;
        set $api_upstream ${API_HOST};
        proxy_pass http://$api_upstream:${API_PORT}/health$is_args$args;
        proxy_http_version 1.1;
        proxy_connect_timeout 3s;
        proxy_read_timeout 3s;
        # No fallback - let it fail to signal API unavailability
    }
    
    # Handle /api and /api/ edge cases - return JSON error, not SPA fallback (#1010)
    # These paths don't correspond to valid API endpoints
    location = /api {
        default_type application/json;
        return 400 '{"error": "Invalid API path", "hint": "Use /api/layouts, /api/assets, or /api/health"}';
    }

    location = /api/ {
        default_type application/json;
        return 400 '{"error": "Invalid API path", "hint": "Use /api/layouts, /api/assets, or /api/health"}';
    }

    location /api/ {
        resolver 127.0.0.11 valid=30s;
        set $api_upstream ${API_HOST};

        # Strip /api prefix: /api/layouts -> /layouts
        # Using rewrite to capture path after /api and forward without prefix
        rewrite ^/api(/.*)$ $1 break;

        proxy_pass http://$api_upstream:${API_PORT};
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_connect_timeout 5s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;

        # Handle API unavailable gracefully
        proxy_intercept_errors on;
        error_page 502 503 504 = @api_unavailable;
    }

    location @api_unavailable {
        default_type application/json;
        return 503 '{"error": "Persistence API unavailable"}';
    }

    # Container health check - used by Docker/K8s for liveness/readiness probes
    # Always returns 200 OK because nginx can serve the frontend even without API
    # This endpoint checks the frontend container health, not API availability
    location = /health {
        access_log off;
        default_type text/plain;
        return 200 "OK";
    }

    # SPA fallback - all routes to index.html
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Security headers (single source of truth: deploy/security-headers.conf)
    include /etc/nginx/snippets/security-headers.conf;
}
